package pkg

import (
	"flag"
	"fmt"
	"log"

	ggen "github.com/PlayerR9/lib_units/generator"
)

var (
	// logger is the logger.
	Logger *log.Logger
)

func init() {
	Logger = ggen.InitLogger("token")
}

type Gen struct {
	PackageName string
	Tokener     string

	TokenType    string
	TypeName     string
	Generics     string
	TypeSig      string
	IteratorName string
	IteratorSig  string

	RuleSig string
}

func (g *Gen) SetPackageName(pkg_name string) {
	g.PackageName = pkg_name
}

var (
	Generator *ggen.CodeGenerator[*Gen]
)

func init() {
	tmp, err := ggen.NewCodeGeneratorFromTemplate[*Gen]("", templ)
	if err != nil {
		Logger.Fatalf("Failed to create code generator: %s", err.Error())
	}

	tmp.AddDoFunc(func(g *Gen) error {
		iter_name, err := ggen.FixVariableName(g.TypeName+"Iterator", nil, ggen.Exported)
		if err != nil {
			return fmt.Errorf("failed to fix variable name: %s", err.Error())
		}

		g.IteratorName = iter_name

		return nil
	})

	tmp.AddDoFunc(func(g *Gen) error {
		token_type, err := ggen.TypeListFlag.GetType(0)
		if err != nil {
			return fmt.Errorf("failed to get type: %s", err.Error())
		}

		g.TokenType = token_type

		return nil
	})

	tmp.AddDoFunc(func(g *Gen) error {
		name, err := ggen.MakeTypeSig(g.TypeName, "")
		if err != nil {
			return fmt.Errorf("failed to make type signature: %s", err.Error())
		}

		g.TypeSig = name

		return nil
	})

	tmp.AddDoFunc(func(g *Gen) error {
		name, err := ggen.MakeTypeSig(g.IteratorName, "")
		if err != nil {
			return fmt.Errorf("failed to make type signature: %s", err.Error())
		}

		g.IteratorSig = name

		return nil
	})

	tmp.AddDoFunc(func(g *Gen) error {
		g.Generics = ggen.GenericsSigFlag.String()

		return nil
	})

	tmp.AddDoFunc(func(g *Gen) error {
		if g.PackageName == "grammar" {
			g.Tokener = "Tokener"
		} else {
			g.Tokener = "grammar.Tokener"
		}

		return nil
	})

	tmp.AddDoFunc(func(g *Gen) error {
		sig, err := ggen.MakeTypeSig("Rule", "")
		if err != nil {
			return fmt.Errorf("failed to make type signature: %s", err.Error())
		}

		g.RuleSig = sig

		return nil
	})

	Generator = tmp
}

var (
	// NameFlag is the name flag.
	NameFlag *string
)

func init() {
	ggen.SetOutputFlag("<type_name>_token.go", true)

	NameFlag = flag.String("name", "", "The name of the token. This flag is required.")

	ggen.SetTypeListFlag("type", true, 1, "The type of the token.")

	ggen.SetGenericsSignFlag("g", false, 1)
}

// templ is the template for the tree node.
const templ = `// Code generated by go generate; DO NOT EDIT
package {{ .PackageName }}

import (
	"strconv"
	"strings"
	"unicode/utf8"

	{{ if ne .PackageName "grammar" }}"github.com/PlayerR9/grammar/grammar"{{ end }}
	"github.com/PlayerR9/lib_units/common"
)

// {{ .IteratorName }} is a pull-based iterator that iterates
// over the children of a {{ .TypeName }}.
type {{ .IteratorName }}{{ .Generics }} struct {
	parent, current *{{ .TypeSig }}
}

// Consume implements the common.Iterater interface.
//
// The only error type that can be returned by this function is the *common.ErrExhaustedIter type.
//
// Moreover, the return value is always of type *{{ .TypeSig }} and never nil; unless the iterator
// has reached the end of the branch.
func (iter *{{ .IteratorSig }}) Consume() ({{ .Tokener }}[{{ .TokenType }}], error) {
	if iter.current == nil {
		return nil, common.NewErrExhaustedIter()
	}

	node := iter.current
	iter.current = iter.current.NextSibling

	return node, nil
}

// Restart implements the common.Iterater interface.
func (iter *{{ .IteratorSig }}) Restart() {
	iter.current = iter.parent.FirstChild
}

// {{ .TypeName }} is a node in a tree.
type {{ .TypeName }}{{ .Generics }} struct {
	Parent, FirstChild, NextSibling, LastChild, PrevSibling *{{ .TypeSig }}

	Type                                                    {{ .TokenType }}
	Data                                                    string
	At                                                      int
	Lookahead                                               *{{ .TypeSig }}
}

// IsLeaf implements the {{ .Tokener }} interface.
func (tk *{{ .TypeSig }}) IsLeaf() bool {
	return tk.FirstChild == nil
}

// Iterator implements the {{ .Tokener }} interface.
//
// This function returns an iterator that iterates over the direct children of the node.
// Implemented as a pull-based iterator, this function never returns nil and any of the
// values is guaranteed to be a non-nil node of type {{ .TypeSig }}.
func (tk *{{ .TypeSig }}) Iterator() common.Iterater[{{ .Tokener }}[{{ .TokenType }}]] {
	return &{{ .IteratorSig }}{
		parent: tk,
		current: tk.FirstChild,
	}
}

// String implements the {{ .Tokener }} interface.
func (tk *{{ .TypeSig }}) String() string {
	var builder strings.Builder

	builder.WriteString("{{ .TypeSig }}[")

	builder.WriteString(tk.Type.String())

	if tk.Data != "" {
		builder.WriteString(" (")
		builder.WriteString(strconv.Quote(tk.Data))
		builder.WriteRune(')')
	}

	builder.WriteString(" : ")
	builder.WriteString(strconv.Itoa(tk.At))
	builder.WriteRune(']')

	return builder.String()
}

// Size implements the grammar.Tokener interface.
func (t *{{ .TypeSig }}) Size() int {
	if t.Data != "" {
		return utf8.RuneCountInString(t.Data)
	}

	var size int

	for c := t.FirstChild; c != nil; c = c.NextSibling {
		size += c.Size()
	}

	return size
}

// GetEofToken implements the grammar.Tokener interface.
func (t *{{ .TypeSig }}) GetEofToken() {{ .Tokener }}[{{ .TokenType }}] {
	return &{{ .TypeSig }}{
		Type: {{ .TokenType }}(0),
		Data: "",
		At: -1,
		Lookahead: nil,
	}
}

// SetLookahead implements the grammar.Tokener interface.
func (t *{{ .TypeSig }}) SetLookahead(lookahead {{ .Tokener }}[{{ .TokenType }}]) {
	if lookahead == nil {
		t.Lookahead = nil

		return
	}

	t.Lookahead = common.AssertConv[*{{ .TypeSig }}](lookahead, "lookahead")
}

// GetLookahead implements the grammar.Tokener interface.
func (t *{{ .TypeSig }}) GetLookahead() {{ .Tokener }}[{{ .TokenType }}] {
	return t.Lookahead
}

// GetType implements the grammar.Tokener interface.
func (t *{{ .TypeSig }}) GetType() {{ .TokenType }} {
	return t.Type
}

// New{{ .TypeName }} creates a new node with the given data.
//
// Parameters:
//   - t_type: The type of the node.
//   - data: The data of the node.
//   - at: The position of the node in the source code.
//   - lookahead: The lookahead of the node.
//
// Returns:
//   - *{{ .TypeSig }}: A pointer to the newly created node. It is
//   never nil.
func New{{ .TypeName }}{{ .Generics }}(t_type {{ .TokenType }}, data string, at int, lookahead *{{ .TypeSig }}) *{{ .TypeSig }} {
	return &{{ .TypeSig }}{
		Type: t_type,
		Data: data,
		At: at,
		Lookahead: lookahead,
	}
}

// AddChildren is a convenience function to add multiple children to the node at once.
// It is more efficient than adding them one by one. Therefore, the behaviors are the
// same as the behaviors of the {{ .TypeName }}.AddChild function.
//
// Parameters:
//   - children: The children to add.
func (tk *{{ .TypeSig }}) AddChildren(children []*{{ .TypeSig }}) {
	if len(children) == 0 {
		return
	}
	
	var top int

	for i := 0; i < len(children); i++ {
		child := children[i]

		if child != nil {
			children[top] = child
			top++
		}
	}

	children = children[:top]
	if len(children) == 0 {
		return
	}

	// Deal with the first child
	first_child := children[0]

	first_child.NextSibling = nil
	first_child.PrevSibling = nil

	last_child := tk.LastChild

	if last_child == nil {
		tk.FirstChild = first_child
	} else {
		last_child.NextSibling = first_child
		first_child.PrevSibling = last_child
	}

	first_child.Parent = tk
	tk.LastChild = first_child

	// Deal with the rest of the children
	for i := 1; i < len(children); i++ {
		child := children[i]

		child.NextSibling = nil
		child.PrevSibling = nil

		last_child := tk.LastChild
		last_child.NextSibling = child
		child.PrevSibling = last_child

		child.Parent = tk
		tk.LastChild = child
	}
}

// Rule is a struct that represents a rule of type {{ .TokenType }}.
type Rule{{ .Generics }} struct {
	// lhs is the left-hand side of the rule.
	lhs {{ .TokenType }}

	// rhss is the right-hand side of the rule.
	rhss []{{ .TokenType }}
}

// Iterator implements the Ruler interface.
func (r *{{ .RuleSig }}) Iterator() common.Iterater[{{ .TokenType }}] {
	return common.NewSimpleIterator(r.rhss)
}

// NewRule creates a new rule.
//
// Parameters:
//   - lhs: The left-hand side of the rule.
//   - rhss: The right-hand side of the rule.
//
// Returns:
//   - *{{ .RuleSig }}: The new rule.
//
// Returns nil if the rhss is empty.
func NewRule{{ .Generics }}(lhs {{ .TokenType }}, rhss []{{ .TokenType }}) *{{ .RuleSig }} {
	if len(rhss) == 0 {
		return nil
	}

	return &{{ .RuleSig }}{
		lhs:  lhs,
		rhss: rhss,
	}
}
`
